/*--------------------------------------------------------------------------------
 _______________
|   /       \   | L   attice-based  | LeMonADE-Viewer:
|  /   ooo   \  | e   xtensible     | ----------------
| /  o\.|./o  \ | Mon te-Carlo      | An Open Source Visualization Tool for
|/  o\.\|/./o  \| A   lgorithm and  | for BFM-files generated by LeMonADE-software.
|  oo---0---oo  | D   evelopment    | See: https://github.com/LeMonADE-project/LeMonADE
|\  o/./|\.\o  /| E   nvironment    |
| \  o/.|.\o  / | -                 |
|  \   ooo   /  | Viewer            | Copyright (C) 2013-2015 by
|___\_______/___|                   | LeMonADE-Viewer Principal Developers (see AUTHORS)
----------------------------------------------------------------------------------

This file is part of LeMonADE-Viewer.

LeMonADE-Viewer is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LeMonADE-Viewer is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeMonADE-Viewer.  If not, see <http://www.gnu.org/licenses/>.

--------------------------------------------------------------------------------*/

#ifndef LEMONADE_VIEWER_LINECOMMAND_H
#define LEMONADE_VIEWER_LINECOMMAND_H

#include <string>
#include <sstream>

#include <LeMonADE/utility/RandomNumberGenerators.h>

template<class IngredientsType, class MoleculesType>
class LineCommandBase
{
public:

	virtual ~LineCommandBase(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& str)=0;

	std::vector<std::string> tokenize1Parameter(const std::string& str,
			char delim) {
		std::vector<std::string> tokens;
		std::stringstream mySstream(str);
		std::string temp;

		while (getline(mySstream, temp, delim)) {
			tokens.push_back(temp);
		}

		return tokens;

	}

	std::vector<std::string> tokenize2Parameter(const std::string& str,	char delim1, char delim2) {
		std::vector<std::string> tokens;
		std::stringstream mySstream(str);
		std::string temp;

		while (getline(mySstream, temp, delim1)) {

			if(temp.size() != 0)
			{
				std::stringstream mySstream2(temp);
				std::string temp2;
				while (getline(mySstream2, temp2, delim2)) {
					//printf("%s \n", temp2.c_str());
					if(temp2.size() != 0)
						tokens.push_back(temp2);
				}
			}

		}

		return tokens;

	}

	std::vector<std::string> tokenize3Parameter(const std::string& str,
			char delim1, char delim2, char delim3) {
		std::vector<std::string> tokens;
		std::stringstream mySstream(str);
		std::string temp;

		while (getline(mySstream, temp, delim1)) {
			std::stringstream mySstream2(temp);
			std::string temp2;
			while (getline(mySstream2, temp2, delim2)) {
				std::stringstream mySstream3(temp2);
				std::string temp3;
				while (getline(mySstream3, temp3, delim3)) {

					//printf("%s \n", temp2.c_str());
					tokens.push_back(temp3);
				}
			}

		}

		return tokens;

	}
};

// handles
// !setColor:idx1-idx2=(r,g,b)
// !setColor:all=(r,g,b)
// !setColor:BG=(r,g,b)

template<class IngredientsType, class MoleculesType>
class CommandSetColor : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColor(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColor");

		//get monomer information
		std::vector<std::string> mono = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(vex[1], '-');

		//mono index has 1 or 2 tokens
		if((mono.size() ==0) || (mono.size() > 2) )
			return std::string("error in command !setColor:monomerindex");

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColor:color");


		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColor:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColor:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColor:blue color");
		}

		//color all monomers
		if(mono.size()==1 && (!mono[0].compare("all")))
		{
			//std::cout << "color all monomers"<< std::endl;

			for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);

			return std::string("apply color to all monomers");
		}

		//color the background
		if(mono.size()==1 && (!mono[0].compare("BG")))
		{
			//std::cout << "color BG"<< std::endl;
			//set background color
			ingredients.setBGcolor(red, green, blue);

			return std::string("apply color to BG");
		}

		// label monomer in range
		if(mono.size()==2)
		{

			uint32_t mono1 = 0;
			uint32_t mono2 = 0;

			std::istringstream ss1(mono[0]);
			ss1 >> mono1;

			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:1.st monomer index");
			}

			if(mono1 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 1.st monomer index");
			}

			std::istringstream ss2(mono[1]);
			ss2 >> mono2;

			if(mono2 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 2.nd monomer index");
			}
			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:2.st monomer index");
			}

			if(mono1 < mono2)
			{
				for(uint32_t i = mono1; i <= mono2; i++)
					ingredients.modifyMolecules()[i].setColor( red ,green , blue);
			}
			else
			{for(uint32_t i = mono2; i <= mono1; i++)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);
			}

			return std::string("apply color monomers");
		}
		return std::string("could not color anything");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetColorAttributes : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorAttributes(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorAttributes " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorAttributes");

		int32_t attribute=0;

		std::istringstream ccAtt(vex[1]);
		ccAtt >> attribute;

		//attribute is wrong
		if(ccAtt.fail()){
			return std::string("error in command !setColorAttributes: attribute");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColorAttributes:color");

		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first color index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColorAttributes:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//second color index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColorAttributes:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//third color index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColorAttributes:blue color");
		}

		//color all monomers
		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].getAttributeTag() == attribute)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);

		return std::string("apply color to all monomers with attribute");
	}
};


template<class IngredientsType, class MoleculesType>
class CommandSetColorLinks : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorLinks(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorLinks " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorLinks");

		int32_t numLinks=0;

		std::istringstream ccLinks(vex[1]);
		ccLinks >> numLinks;

		//numLinks is wrong
		if(ccLinks.fail()){
			return std::string("error in command !setColorLinks: numLinks");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColorLinks:color");

		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColorLinks:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColorLinks:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColorLinks:blue color");
		}

		//color all monomers


		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
		{
			if(ingredients.modifyMolecules().getNumLinks(i) == numLinks)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);
		}

		return std::string("apply color to all monomers with numLinks");
	}
};


template<class IngredientsType, class MoleculesType>
class CommandSetVisible : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetVisible(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetVisible in CommandSetVisible " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setVisible");

		//get monomer information
		std::vector<std::string> mono = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(vex[1], '-');

		//mono index has 1 or 2 tokens
		if((mono.size() ==0) || (mono.size() > 2) )
			return std::string("error in command !setVisible: monomer index");

		//get visibility information
		int visible =0;

		std::istringstream ccVisible(vex[2]);
		ccVisible >> visible;

		//first mono index is wrong
		if(ccVisible.fail()){
			return std::string("error in command !setVisible: visibility");
		}

		//color all monomers
		if(mono.size()==1 && (!mono[0].compare("all")))
		{
			std::cout << "set visible all monomers"<< std::endl;

			for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
				ingredients.modifyMolecules()[i].setVisible(bool(visible));

			return std::string("set visibility to all monomers");
		}

		// label monomer in range
		if(mono.size()==2)
		{
			uint32_t mono1 = 0;
			uint32_t mono2 = 0;

			std::istringstream ss1(mono[0]);
			ss1 >> mono1;

			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:1.st monomer index");
			}

			if(mono1 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 1.st monomer index");
			}

			std::istringstream ss2(mono[1]);
			ss2 >> mono2;

			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor: 2.st monomer index");
			}

			if(mono2 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 2.nd monomer index");
			}

			if(mono1 < mono2)
			{
				for(uint32_t i = mono1; i <= mono2; i++)
					ingredients.modifyMolecules()[i].setVisible(bool(visible));
			}
			else
			{for(uint32_t i = mono2; i <= mono1; i++)
				ingredients.modifyMolecules()[i].setVisible(bool(visible));
			}

			return std::string("apply visibility to monomers");
		}
		return std::string("could not set visibility to monomers");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetVisibleAttributes : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetVisibleAttributes(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetVisible in CommandSetVisibleAttributes " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setVisibleAttributes");

		int32_t attribute=0;

		std::istringstream ccAtt(vex[1]);
		ccAtt >> attribute;

		//attribute is wrong
		if(ccAtt.fail()){
			return std::string("error in command !setColorAttributes: attribute");
		}

		//get visibility information
		int visible =0;

		std::istringstream ccVisible(vex[2]);
		ccVisible >> visible;

		if(ccVisible.fail()){
			return std::string("error in command !setVisibleAttributes: Visibility");
		}



		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].getAttributeTag() == attribute)
				ingredients.modifyMolecules()[i].setVisible( (bool(visible)));

		return std::string("apply visiblility to all monomers with attribute");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetVisibleLinks : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetVisibleLinks(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetVisible in CommandSetVisibleLinks " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setVisibleLinks");

		int32_t numLinks=0;

		std::istringstream ccLinks(vex[1]);
		ccLinks >> numLinks;

		//attribute is wrong
		if(ccLinks.fail()){
			return std::string("error in command !setColorLinks: numLinks");
		}

		//get visibility information
		int visible =0;

		std::istringstream ccVisible(vex[2]);
		ccVisible >> visible;

		if(ccVisible.fail()){
			return std::string("error in command !setVisibleLinks: Visibility");
		}

		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules().getNumLinks(i) == numLinks)
				ingredients.modifyMolecules()[i].setVisible( (bool(visible)));

		return std::string("apply visiblility to all monomers with attribute");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetColorVisibility : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorVisibility(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorVisibility " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorVisibility");

		int32_t Visibility=0;

		std::istringstream ccVis(vex[1]);
		ccVis >> Visibility;

		//attribute is wrong
		if(ccVis.fail()){
			return std::string("error in command !setColorVisibility: Visibility");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColorVisibility: Color");


		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColorVisibility:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColorVisibility:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColorVisibility:blue color");
		}


		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].isVisible() == (bool(Visibility)))
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);

		return std::string("apply color to all (in)visible monomers ");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetVisibleGroups : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetVisibleGroups(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetVisible in CommandSetVisibleGroups " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 4 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setVisibleGroups");

		//get monomer information
		std::vector<std::string> Groups = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(vex[1], '-');

		//mono index has 1 or 2 tokens
		if((Groups.size() != 2) )
			return std::string("error in command !setVisible: monomer index");

		uint32_t group1 = 0;
		uint32_t group2 = 0;

		std::istringstream ss1(Groups[0]);
		ss1 >> group1;

		//first mono index is wrong
		if(ss1.fail()){
			return std::string("error in command !setColor:1.st group index");
		}

		if((group1 < 0) || (group1 >= molecules_type.size()))
		{
			return std::string("error in command !setColor: out-of-range 1.st group index");
		}

		std::istringstream ss2(Groups[1]);
		ss2 >> group2;

		//first mono index is wrong
		if(ss1.fail()){
			return std::string("error in command !setColor: 2.st group index");
		}

		if((group2 < 0) || (group2 >= molecules_type.size()))
		{
			return std::string("error in command !setColor: out-of-range 2.nd monomer index");
		}

		//get visibility information
		int visible =0;

		std::istringstream ccGroup(vex[2]);
		ccGroup >> visible;

		if(ccGroup.fail()){
			return std::string("error in command !setVisibleGroups: Visibility");
		}



		if(group1 < group2)
		{
			for(uint32_t i = group1; i <= group2; i++)
				for(size_t m=0; m< molecules_type[i].size(); ++m)
					ingredients.modifyMolecules()[molecules_type[i].trueIndex(m)].setVisible( (bool(visible)));


		}
		else
		{
			for(uint32_t i = group2; i <= group1; i++)
				for(size_t m=0; m< molecules_type[i].size(); ++m)
					ingredients.modifyMolecules()[molecules_type[i].trueIndex(m)].setVisible( (bool(visible)));

		}

		return std::string("visible color to all monomers within Groups");

	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetColorGroups : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorGroups(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorGroups " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setColorGroups");

		int32_t group=0;

		std::istringstream ccGroup(vex[1]);
		ccGroup >> group;

		//Group is wrong
		if(ccGroup.fail()){
			return std::string("error in command !setColorGroups: Groups");
		}

		if((group < 0) || (group >= molecules_type.size()))
		{
			return std::string("error in command !setColorGroups: Groups exceed range");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setColorGroups:color");


		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first mono index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setColorGroups:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//first mono index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setColorGroups:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//first mono index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setColorGroups:blue color");
		}


		for(size_t m=0; m< molecules_type[group].size(); ++m){
			ingredients.modifyMolecules()[molecules_type[group].trueIndex(m)].setColor( red ,green , blue);

		}

		return std::string("apply color to all monomers within Groups");

	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetColorGroupsRandom : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetColorGroupsRandom(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetColorGroupsRandom " << std::endl;

		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 1 tokens
		if(vex.size() !=1 )
			return std::string("error in command !setColorGroups");

		RandomNumberGenerators RNG;

		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		//std::cout << "color all monomers whithin group"<< std::endl;
		for(size_t n=0; n< molecules_type.size(); ++n){

			red = RNG.r250_drand();
			green = RNG.r250_drand();
			blue = RNG.r250_drand();

			for(size_t m=0; m< molecules_type[n].size(); ++m){
				ingredients.modifyMolecules()[molecules_type[n].trueIndex(m)].setColor( red ,green , blue);

			}
		}
		return std::string("apply color to all monomers within Groups");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetRadius : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetRadius(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		std::cout << "!SetRadius in CommandSetRadius " << std::endl;

		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setRadius");

		//get monomer information
		std::vector<std::string> mono = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(vex[1], '-');

		//mono index has 1 or 2 tokens
		if((mono.size() ==0) || (mono.size() > 2) )
			return std::string("error in command !setRadius:monomerindex");

		//get radius information
		float radius = 0.0f;

		std::istringstream ccRadius(vex[2]);
		ccRadius >> radius;

		//first mono index is wrong
		if(ccRadius.fail()){
			return std::string("error in command !setRadiusr:Radius");
		}

		if(radius <= 0.0f)
		{
			return std::string("error: radius <= 0.0f");
		}

		//color all monomers
		if(mono.size()==1 && (!mono[0].compare("all")))
		{
			std::cout << "color all monomers"<< std::endl;

			for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
				ingredients.modifyMolecules()[i].setRadius( radius);

			return std::string("apply radius to all monomers");
		}

		// label monomer in range
		if(mono.size()==2)
		{
			//uint32_t mono1 = atoi(mono[0].c_str());
			//uint32_t mono2 = atoi(mono[1].c_str());

			uint32_t mono1 = 0;
			uint32_t mono2 = 0;

			std::istringstream ss1(mono[0]);
			ss1 >> mono1;

			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:1.st monomer index");
			}

			if(mono1 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 1.st monomer index");
			}

			std::istringstream ss2(mono[1]);
			ss2 >> mono2;

			if(mono2 >= ingredients.modifyMolecules().size())
			{
				return std::string("error in command !setColor: out-of-range 2.nd monomer index");
			}
			//first mono index is wrong
			if(ss1.fail()){
				return std::string("error in command !setColor:2.st monomer index");
			}


			if(mono1 < mono2)
			{
				for(uint32_t i = mono1; i <= mono2; i++)
					ingredients.modifyMolecules()[i].setRadius( radius);
			}
			else
			{for(uint32_t i = mono2; i <= mono1; i++)
				ingredients.modifyMolecules()[i].setRadius( radius);
			}

			return std::string("apply radius monomers");
		}
		return std::string("could not change radius monomers");
	}
};


template<class IngredientsType, class MoleculesType>
class CommandSetRadiusAttributes : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetRadiusAttributes(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetRadius in CommandSetRadiusAttributes " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setRadiusAttributes");

		int32_t attribute=0;

		std::istringstream ccAtt(vex[1]);
		ccAtt >> attribute;

		//attribute is wrong
		if(ccAtt.fail()){
			return std::string("error in command !setRadiusAttributes: attribute");
		}

		//get radius information
		float radius = 0.0f;

		std::istringstream ccRadius(vex[2]);
		ccRadius >> radius;

		//first mono index is wrong
		if(ccRadius.fail()){
			return std::string("error in command !setRadius:Radius");
		}

		if(radius <= 0.0f)
		{
			return std::string("error: radius <= 0.0f");
		}

		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].getAttributeTag() == attribute)
				ingredients.modifyMolecules()[i].setRadius( radius);

		return std::string("apply radius to all monomers with attribute");

	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetRadiusLinks : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetRadiusLinks(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetRadiusLinks " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setRadiusLinks");

		int32_t numLinks=0;

		std::istringstream ccLinks(vex[1]);
		ccLinks >> numLinks;

		//numLinks is wrong
		if(ccLinks.fail()){
			return std::string("error in command !setRadiusLinks: numLinks");
		}

		//get radius information
		float radius = 0.0f;

		std::istringstream ccRadius(vex[2]);
		ccRadius >> radius;

		//first mono index is wrong
		if(ccRadius.fail()){
			return std::string("error in command !setRadius:Radius");
		}

		if(radius <= 0.0f)
		{
			return std::string("error: radius <= 0.0f");
		}


		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules().getNumLinks(i) == numLinks)
				ingredients.modifyMolecules()[i].setRadius( radius);

		return std::string("apply radius to all monomers with numLinks");
	}
};


template<class IngredientsType, class MoleculesType>
class CommandSetRadiusGroups : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetRadiusGroups(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		//std::cout << "!SetColor in CommandSetRadiusGroups " << std::endl;
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setRadiusGroups");

		int32_t group=0;

		//color all monomers

		std::istringstream ccGroup(vex[1]);
		ccGroup >> group;

		//Group is wrong
		if(ccGroup.fail()){
			return std::string("error in command !setRadiusGroups: Groups");
		}

		if((group < 0) || (group >= molecules_type.size()))
		{
			return std::string("error in command !setColorGroups: Groups exceed range");
		}

		//get radius information
		float radius = 0.0f;

		std::istringstream ccRadius(vex[2]);
		ccRadius >> radius;

		//first mono index is wrong
		if(ccRadius.fail()){
			return std::string("error in command !setRadius:Radius");
		}

		if(radius <= 0.0f)
		{
			return std::string("error: radius <= 0.0f");
		}


		for(size_t m=0; m< molecules_type[group].size(); ++m){
			ingredients.modifyMolecules()[molecules_type[group].trueIndex(m)].setRadius( radius);
		}

		return std::string("apply color to all monomers within Groups");
	}
};

template<class IngredientsType, class MoleculesType>
class CommandSetSyncAttributeColor : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetSyncAttributeColor(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize1Parameter(_commandLine, ':');

		//command has 2 tokens
		if(vex.size() !=2 )
			return std::string("error in command !setSyncAttributesON");

		uint32_t sync=0;

		std::istringstream ccAtt(vex[1]);
		ccAtt >> sync;

		//attribute is wrong
		if(ccAtt.fail()){
			return std::string("error in command !setSyncAttributesON: attribute");
		}
		
		ingredients.setSyncAttributeColor(sync);
		return std::string("set the synchronize of the attribute colors");
	}
};
template<class IngredientsType, class MoleculesType>
class CommandSetAttributeColorMap : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandSetAttributeColorMap(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		std::vector<std::string> vex = LineCommandBase<IngredientsType, MoleculesType>::tokenize2Parameter(_commandLine, ':', '=');

		//command has 3 tokens
		if(vex.size() !=3 )
			return std::string("error in command !setAttributeColorMap");

		int32_t attribute=0;

		std::istringstream ccAtt(vex[1]);
		ccAtt >> attribute;

		//attribute is wrong
		if(ccAtt.fail()){
			return std::string("error in command !setAttributeColorMap: attribute");
		}

		//get color information
		std::vector<std::string> color = LineCommandBase<IngredientsType, MoleculesType>::tokenize3Parameter(vex[2], '(', ',' , ')');

		if(color.size() !=3 )
			return std::string("error in command !setAttributeColorMap:color");

		float red = 0.0f;
		float green = 0.0f;
		float blue = 0.0f;

		std::istringstream ccRed(color[0]);
		ccRed >> red;

		//first color index is wrong
		if(ccRed.fail()){
			return std::string("error in command !setAttributeColorMap:red color");
		}

		std::istringstream ccGreen(color[1]);
		ccGreen >> green;

		//second color index is wrong
		if(ccGreen.fail()){
			return std::string("error in command !setAttributeColorMap:green color");
		}

		std::istringstream ccBlue(color[2]);
		ccBlue >> blue;

		//third color index is wrong
		if(ccBlue.fail()){
			return std::string("error in command !setAttributeColorMap:blue color");
		}
		
		//color all monomers
		for(uint32_t i = 0; i < ingredients.modifyMolecules().size(); i++)
			if(ingredients.modifyMolecules()[i].getAttributeTag() == attribute)
				ingredients.modifyMolecules()[i].setColor( red ,green , blue);
		ingredients.addAttributeColor(attribute, red, green ,blue );
		
		std::cout <<" Added color " << ingredients.getAttributeColor(attribute)  << std::endl;
		return std::string(" set a color for the attribute color map");
	}
};



template<class IngredientsType, class MoleculesType>
class CommandGetHelp : public LineCommandBase<IngredientsType, MoleculesType>
{
public:
	virtual ~CommandGetHelp(){};

	virtual std::string executeLineCommand(IngredientsType& ingredients, MoleculesType& molecules_type, std::string& _commandLine)
	{
		std::cout << "!help with known commands" << std::endl;

		return std::string("known commands:\n"
				"!setColor:idx1-idx2=(r,g,b)\n"
				"!setColor:all=(r,g,b)\n"
				"!setColorAttributes:att=(r,g,b)\n"
				"!setColorLinks:numLinks=(r,g,b)\n"
				"!setColorVisibility:vis=(r,g,b)\n"
				"!setColorGroups:idxGroup=(r,g,b)\n"
				"!setColorGroupsRandom\n"
				"!setColor:BG=(r,g,b)\n"
				"!setVisible:idx1-idx2=vis\n"
				"!setVisible:all=vis\n"
				"!setVisibleAttributes:att=vis\n"
				"!setVisibleLinks:numLinks=vis\n"
				"!setVisibleGroups:idxG1-idxG2=vis\n"
				"!setRadius:idx1-idx2=radius\n"
				"!setRadius:all=radius\n"
				"!setRadiusAttributes:att=radius\n"
				"!setRadiusLinks:numLinks=radius\n"
				"!setRadiusGroups:idxGroup=radius\n"
				"!setAttributeColorMap:att=(red,green,blue)\n"
				"!setSyncAttributesON:0/1\n" );
	}
};


#endif /* LEMONADEVIEWERLINECOMMAND_H_ */
